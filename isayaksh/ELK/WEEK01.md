# Elasticsearch

- **Elasticsearch**는 **수평 확장성**, **신뢰성**, **쉬운 관리**를 위해 설계된 강력한 오픈소스 **검색 및 분석 엔진**입니다.
- Apache Lucene 위에 구축되었으며, LogStash 및 Kibana를 포함하는 Elastic Stack의 일부입니다.
- **분산 구조**: Elasticsearch는 데이터를 자동으로 분산 저장하고 쿼리 부하를 클러스터 내 모든 노드에 분산 처리합니다. 대용량 데이터를 거의 실시간으로 처리할 수 있습니다.
- **전문 검색 기능**: Elasticsearch는 고급 전문(full-text) 검색 기능을 위해 설계되었으며, HTTP 웹 인터페이스와 스키마 없는 JSON 문서를 지원합니다.
- **확장성**: 수백에서 수천 대의 서버로 확장 가능하며, 페타바이트급의 구조화 및 비구조화 데이터를 처리할 수 있습니다.
- **유연성**: 다양한 소스로부터 이질적인 데이터 타입을 색인화하고, 복잡한 검색을 수행할 수 있도록 지원합니다.

# Component

## Document & Field

- **Document (문서)**: Elasticsearch에서 문서는 색인할 수 있는 기본 정보 단위입니다. 각 문서는 경량의 데이터 교환 형식인 JSON(JavaScript Object Notation)으로 표현됩니다.
- **Field (필드)**: 필드는 Elasticsearch에서 가장 작은 데이터 단위이며, 문서 내의 키-값 쌍을 나타냅니다.

```json
/* Document */
{
	"name" : "kim", // Field 
	"age" : 30,
	"email" : "isayaksh@gmail.com"
}
```

# **Common Use Cases**

---

- **엔터프라이즈 검색**: 기업이 전체 디지털 콘텐츠를 색인화하고 웹사이트나 내부 네트워크 전반에 걸쳐 고급 검색 기능을 제공하는 데 사용됩니다.
- **로그 수집 및 분석**: Logstash 및 Kibana와 함께 로그를 분석하여 IT 운영, 보안, 성능 모니터링에 활용됩니다.
- **보안 정보 및 이벤트 관리(SIEM)**: 실시간으로 보안 데이터를 분석 및 시각화하여 위협 탐지 및 규정 준수 관리를 지원합니다.
- **데이터 분석**: 빅데이터를 빠르게 탐색하고 다양한 방식으로 분석할 수 있도록 지원합니다.
- **개인화 및 추천 시스템**: 이커머스 웹사이트에서 사용자 행동을 분석하여 개인화된 상품 추천이나 동적 콘텐츠를 제공합니다.

# How does Elasticsearch work?

---

## **Data Distribution and Storage**

- **색인화(Indexing)**: Elasticsearch에서 데이터는 **인덱스(Index)** 단위로 구성되며, 이는 데이터베이스와 유사합니다. 인덱스 내의 문서는 **JSON 형식**으로 저장됩니다. 문서가 인덱스에 추가되면 Elasticsearch는 이를 검색 최적화된 형식으로 변환하여 색인화합니다.
- **샤딩(Sharding)**: **하나의 인덱스는 여러 샤드로 분할될 수 있으며**, 이를 통해 클러스터 내 여러 노드에 분산 저장됩니다. 이는 고가용성과 성능 확장성을 가능하게 합니다. 대규모 데이터셋과 높은 쿼리 부하 처리를 위해 핵심적인 기능입니다.
- **복제(Replicas)**: Elasticsearch는 **기본 샤드의 복제본인 레플리카 샤드**를 생성할 수 있습니다. 복제본은 **데이터 중복성**을 제공하여 하드웨어 장애로부터 데이터를 보호하고, **쿼리 처리 용량**도 증가시킵니다.

## **Search Mechanisms**

- **쿼리 처리(Query Processing)**: 쿼리가 제출되면 이를 파싱(parsing)하고 Lucene 인덱스에서 검색할 수 있도록 적절한 형식으로 변환합니다. 그 후 **모든 관련 샤드(기본 또는 복제 샤드)에 병렬로 실행**됩니다.
- **적합도 점수(Relevance Scoring)**: Elasticsearch는 **TF-IDF**, **BM25**와 같은 알고리즘을 사용하여 문서가 쿼리와 얼마나 잘 일치하는지를 점수화합니다. 이 점수는 검색 결과의 순위를 정하는 데 사용됩니다.

## **Real-Time Operations**

- **Near Real-Time (NRT) 검색**: Elasticsearch는 거의 실시간(NRT)으로 데이터를 색인화하고 검색할 수 있는 기능을 제공합니다. 이를 위해 **메모리 버퍼**에 문서를 임시로 저장한 후 **주기적으로 디스크에 저장(플러시)** 합니다.

## Cluster Management

- **노드와 클러스터(Nodes and Clusters)** : Elasticsearch 클러스터는 하나 이상의 노드(서버)로 구성되며, 이들 노드는 함께 **전체 데이터를 저장하고 색인 및 검색 기능을 제공합니다**. 클러스터는 기본적으로 "elasticsearch"라는 고유 이름을 가집니다.
- **마스터 노드(Master Node)**: 마스터 노드는 **클러스터의 상태 및 메타데이터를 관리**합니다. 새 문서 추가와 샤드 할당을 추적합니다.
- **노드 간 통신(Node Communication)**: 노드들은 RESTful API를 통해 HTTP로 JSON을 주고받거나, Elasticsearch 내부 전송 프로토콜을 사용해 서로 통신합니다.

## Analysis and Aggregation

- **분석(Analysis)**: Elasticsearch는 색인화 중에 **텍스트 분석(text analysis)** 을 수행합니다. (텍스트를 토큰 또는 용어로 분해함) 사용자 정의 토크나이저, 필터, 분석기를 사용하여 매우 유연하게 구성할 수 있습니다.
- **집계(Aggregation)**: 이 기능을 통해 사용자들은 **데이터에 대한 복잡한 요약 및 인사이트**를 얻을 수 있습니다. 집계는 합계, 평균 등의 **메트릭 계산**, **버킷화(그룹핑)**, **중첩 집계** 등을 통해 계층적으로 데이터를 탐색할 수 있습니다.

# Elastic Stack

### 1. **Beats (데이터 수집)**

- **경량 데이터 수집 에이전트**
- 시스템 로그, 메트릭, 파일 로그 등을 수집
- 종류:
    - Filebeat: 로그 파일 수집
    - Metricbeat: 시스템 및 서비스 메트릭 수집
    - Packetbeat: 네트워크 트래픽 수집 등

→ 데이터를 Kafka 또는 Logstash로 전송

---

### 2. **Kafka (중간 버퍼 및 큐)**

- **데이터 스트림 처리 플랫폼**
- Beats와 Logstash 사이의 **비동기 처리**를 위한 중간 계층
- **대용량 로그 처리 시 필수적** (장애 복원력 ↑, 유실 ↓)

→ Logstash가 Kafka에서 데이터를 읽음

---

### 3. **Logstash (수집 & 변환)**

- **데이터 파싱, 필터링, 변환 처리**
- 다양한 input (Kafka, Beats, DB 등) → output (Elasticsearch 등) 연결
- Grok, mutate, date 등 필터 플러그인 사용 가능

→ Elasticsearch에 전송 가능한 구조로 데이터 가공 후 전송

---

### 4. **Elasticsearch (저장 & 검색)**

- **색인(Index) 저장소이자 검색 엔진**
- 구조화 및 비구조화 데이터 저장
- 실시간 검색 및 분석 기능 제공
- 고가용성/수평 확장 가능

→ Kibana가 이 데이터를 시각화에 사용

---

### 5. **Kibana (시각화)**

- **Elasticsearch 데이터를 시각적으로 표현**
- 대시보드, 차트, 로그 탐색, SIEM 기능 등 제공
- 사용자가 쉽게 데이터를 분석하고 모니터링할 수 있게 함

## 아키텍처 (Architecture)

- **클러스터(Cluster)**:
    
    Elasticsearch 클러스터는 **하나 이상의 노드로 구성된 집합**이다.
    
    클러스터는 고유한 이름을 통해 자신을 식별하고, 데이터를 분산 저장 및 공동 관리한다.
    
- **노드(Node)**:
    
    Elasticsearch의 **각 인스턴스**는 노드라고 부른다.
    
    노드는 데이터를 저장하고 클러스터 내 **색인 및 검색 작업**에 참여한다.
    
- **노드 유형 (Types of nodes)**
    - **마스터 노드(Master Node)**: 인덱스 생성/삭제와 노드 상태 관리 같은 **클러스터 전반의 작업을 관리**한다.
    - **데이터 노드(Data Node)**: 데이터를 저장하고 **CRUD, 검색, 집계** 작업을 처리한다.
    - **인제스트 노드(Ingest Node)**: 색인 전에 필터링 또는 풍부화(enrichment)와 같은 **데이터 변환 작업을 처리**한다.
    - **조정 노드(Coordinating Node)**:
        
        **클라이언트 요청을 전달**하고, 검색 요청의 부하를 **여러 노드에 분산**시킨다.
        
- **인덱스(Index)**:
    
    인덱스는 **문서를 구성하는 논리적 네임스페이스**이다.
    
    Elasticsearch에서 인덱스는 관계형 데이터베이스의 테이블과 유사하다.
    
- **문서(Document)**:
    
    문서는 색인 가능한 정보 단위이다.
    
    필드로 구성된 **JSON 객체** 형태로, 데이터 속성을 나타낸다.
    
- **샤드(Shard)**:
    
    인덱스는 **샤드라는 더 작은 조각들로 분할**될 수 있다.
    
    샤드는 데이터를 클러스터 내 여러 노드에 분산 저장할 수 있게 해주며,
    
    각 샤드는 Lucene의 소규모 인스턴스라고 볼 수 있다.
    
    - 샤드에는 두 가지 유형이 있다:
        - **기본 샤드(Primary Shard)**:
            
            인덱스를 생성하고 **CRUD 작업을 직접 수행**한다.
            
        - **복제 샤드(Replica Shard)**:
            
            **기본 샤드의 복사본**으로, **중복성과 고가용성**을 제공한다.
            

### 로지컬 메커니즘

- **레플리카**: 각 주요 샤드는 결함 허용을 위해 0개 이상의 레플리카를 가질 수 있습니다. 레플리카는 검색 성능 향상을 위해 읽기 요청을 처리하기도 합니다.
- **라우팅 테이블**: 어떤 노드가 어떤 샤드를 보유하고 있는지 결정합니다. 이 정보는 마스터 노드에 의해 업데이트되며, 조정 노드가 적절한 샤드로 요청을 전달하는 데 사용됩니다.
- **게이트웨이**: Elasticsearch가 클러스터와 인덱스의 상태를 유지하는 메커니즘입니다. 메타데이터를 유지하며 노드가 실패할 경우 이 정보를 복구할 수 있습니다.
- **디스커버리 모듈**: 새로운 노드가 기존 클러스터에 원활하게 합류할 수 있도록 하며, 노드 상태 변경을 관리합니다.

### **복제(Replication)**

- Elasticsearch에서의 복제는 **데이터 중복성, 고가용성, 장애 허용성을 보장하기 위해 데이터의 중복 사본을 생성하는 과정**입니다.

### **샤드와 복제본(Shards and Replicas)**

- **기본 샤드(Primary Shard)**: Elasticsearch의 각 인덱스는 기본 샤드로 나뉘며, 원본 데이터의 색인과 저장을 처리합니다.
- **복제 샤드(Replica Shard)**: 복제 샤드는 기본 샤드의 복사본으로, **백업** 역할을 하며 동시에 **쿼리 부하**를 분산합니다.

### **복제 동작(Replication Behavior)**

- **기본-복제 관계**: 하나의 기본 샤드는 0개 이상의 복제 샤드를 가질 수 있습니다.
- **쓰기 작업**: 문서가 기본 샤드에 색인(쓰기)될 때, 해당 문서는 모든 복제 샤드에 복제됩니다. 이는 데이터의 **일관성**을 보장합니다.
- **읽기 작업**: 검색 쿼리는 기본 샤드 또는 복제 샤드 중 아무거나 처리할 수 있어, **읽기 부하를 분산**하고 성능을 향상시킵니다.

### 꼭 알아야 하는 3가지

- **고가용성(High Availability)**: 기본 샤드를 가진 노드가 장애를 일으킬 경우, 복제 샤드 중 하나가 기본 샤드로 승격되어 데이터 접근성을 보장합니다.
- **부하 분산(Load Balancing)**: 검색 요청을 기본 샤드 또는 복제 샤드로 라우팅할 수 있어 검색 성능이 향상됩니다.
- **데이터 중복성(Data Redundancy)**: 여러 노드에 데이터를 복제함으로써, 노드 장애로 인한 데이터 손실을 방지합니다.

### **복제 시 고려사항**

- **노드 수(Number of Nodes)**: 복제 설정을 지원할 수 있을 만큼 충분한 노드를 확보해야 합니다. **하나의 노드는 동일한 인덱스 샤드의 기본 샤드와 복제 샤드를 동시에 가질 수 없습니다**.
- **네트워크 및 저장소 오버헤드(Network and Storage Overhead)**: 복제를 통해 데이터가 중복되므로, 추가적인 네트워크 트래픽과 저장 공간이 필요합니다.
- **트레이드오프(Trade-offs)**: 데이터 안전성(더 많은 복제본 확보)과 리소스 사용량(디스크 및 네트워크) 사이에는 절충이 필요합니다.


# Document CRUD에 대해 알아보기

Document는 IMMUTABLE(불변) 속성을 가진다. 따라서, ES에서는 한 번 색인된 문서(Document Indexed)는 직접 **수정되지 않는다.** 대신, **기존 문서를 삭제**하고, **새로운 문서를 생성**하는 방식으로 동작한다.

새로 생성된 문서는 Document 내부의 `_version` 필드가 생성된다. 수정과 추가가 발생할때마다 `_version` 이 증가하는 방식으로 동작한다.

그러나, **기존 문서를 물리적으로 즉시 삭제하는 것이 아니라, 삭제 플래그만 추가**하는 방식으로 삭제 처리를 진행한다. 실제 삭제 처리는 **segment merge 시 디스크에서 제거**되는 방식을 사용한다.

segment는 실제 **Document들이 저장되는 물리적인 파일 단위**이자 **Lucene의 저장 단위**라고 볼 수 있다.

Document의 IMMUTABLE한 속성이 가지는 Benefit은 뭘까?

1. 검색 성능 향상
~~Document가 불변이기 때문에, Segment는 수정되지 않는다~~. 이에 따라, Segment는 READ 최적화 구조를 유지할 수 있게된다.
2. 병렬 처리 유리
여러 Thread나 Query가 동시에 Segment를 읽더라도, 내용이 변하지 않으므로 **락(lock) 필요 없다.** 또한, 동시성 문제가 발생하지 않기 때문에 빠르고 안정적인 검색이 가능하다.
3. Segment 구조 단순화
Segment가 불변이기 때문에 내부 데이터 구조를 최적화해서 압축, 정렬, 역색인 구축을 효율적으로 수행이 가능하다.
4. 빠른 롤백 및 재색인 용이
문서가 삭제되고 새로운 문서가 들어와도, **기존 Segment는 그대로 두고 새로운 Segment만 추가**하면 된다. 또한 복구, 복제, 스냅샷 시도도 쉽게 가능하기 때문에 분산 시스템에 더 적합하다고 할 수 있다.
5. 버전 관리 및 충돌 방지
Immutable 구조 덕분에 `_version` 기반의 **~~Optimistic Locking~~**이 자연스럽게 동작한다. 동일한 문서를 동시에 수정하려는 경우 감지가 가능하기 때문에, 수정 충돌을 최소화할 수 있다.

단점은?

1. 리소스 낭비
문서 하나 업데이트 시에도 새 문서 + 삭제 마크 → 디스크 낭비, Merge 필요
2. 성능 저하 가능
Segment가 많아지면 검색 속도 느려짐 → 주기적 Merge로 CPU/IO 비용 발생
3. 실시간 업데이트용 아님
초당 수천 건의 업데이트가 일어나는 서비스에는 구조적으로 부담이 큼

## 🏗 Elasticsearch 아키텍처 계층 구조

```
[Cluster]
   └── [Node]
         └── [Index]
               └── [Shard]  ← ★ 논리적 단위
                     └── [Segment]  ← ★ 실제 물리 저장 단위
```

---

### 1. Cluster (클러스터)

- Elasticsearch 전체 시스템.
- 여러 대의 **Node(서버)** 들이 하나의 Cluster를 구성.
- 예: `production-cluster`, `log-cluster`

### 2. Node (노드)

- Elasticsearch가 설치된 **물리 서버 또는 인스턴스 하나**.
- 각 노드는 여러 개의 샤드를 가질 수 있음.

### 3. Index (인덱스)

- 데이터의 논리적 집합.
- 예: `user-index`, `log-2025-04-10`
- 내부적으로 여러 개의 **Shard(기본: 5 primary)** 로 나뉨.

### 4. Shard (샤드)

- Index를 나누는 **논리적 파티션**.
- **Primary Shard**와 **Replica Shard**가 있음.
- Shard는 Lucene 인스턴스라고 보면 됨 → 즉, 자체적인 색인 & 검색 가능.

### 5. Segment (세그먼트)

- **Shard 내부의 Lucene 구조에서 가장 하위 단위**.
- 실제 **Document들이 저장되는 물리적인 파일 단위**.
- 한 Shard에는 여러 개의 Segment가 존재하고, 이는 계속 생기고, 병합됨.
- 즉, Segment는 "Lucene의 저장 단위"이자 "Shard의 내부 구성 요소".

## 📚 비유 정리: Elasticsearch = 도서관

| 개념 | 비유 | 설명 |
| --- | --- | --- |
| **Cluster** | 도서관 전체 | 여러 건물(Node)로 구성된 시스템 |
| **Node** | 도서관 건물 하나 | 색인을 담당하는 물리/가상 서버 |
| **Index** | 주제별 섹션 | 예: 과학책 섹션, 뉴스기사 섹션 등 |
| **Shard** | 책장/선반 | Index를 나눈 작은 단위, Lucene 인스턴스 |
| **Segment** | 책 더미 (묶음) | 선반에 쌓인 책 파일 묶음 (불변) |
| **Document** | 책 한 권 | JSON 문서 하나 (Elasticsearch의 최소 단위) |
| **Field** | 책의 챕터/페이지 | 문서 내 속성들 (`title`, `content`, `author` 등) |

# Script로 Document 변경해보기
**ES**에서 **File Script 사용을 지양**하는 이유는 **보안** 및 **유연성** 때문이다.

보안

- 악의적인 사용자가 **취약한 스크립트를 업로드하거나 수정할 경우 원격 코드 실행(RCE) 등의 보안 위협**으로 이어질 수 있다.
- 서버에 접근 가능한 사용자가 **악성 스크립트를 삽입하면 ElasticSearch 인스턴스를 통해 내부 시스템까지 침투**할 수 있다.

유연성

- File Script는 **각 노드에 물리적으로 파일을 배포**해야 하므로, **클러스터가 여러 노드로 구성된 경우 파일 동기화 문제 발생!**
- 일반적으로 **ElasticSearch를 재시작하거나 캐시를 지워야만 변경 사항이 반영**된다.

따라서, File Script는 사용하지 않는 것이 올바른 방법이다.

---

ES는 **보안 강화**와 **성능 최적화**를 목적으로 **Painless**라는 자체 스크립트 언어를 사용한다.

ES를 안정된 상태로 유지하기 위해서는 동적 스크립트 사용은 지양하고, Disable한 상태로 유지하는 것이 중요하다. 이유는 다음과 같다.

1. **성능문제**
동적 스크립트는 요청마다 새 스크립트를 파싱하고, 바이트 코드로 변환하는 과정에서 CPU를 사용하게 됨. 특히, 검색 쿼리에 자주 포함될 경우, 노드 전체의 처리량 감소 및 GC 부하가 증가함.
2. **보안문제**
악의적인 사용자가 **무한 루프, 리소스 과다 사용** 같은 코드를 실행시켜 노드를 다운시킬 수도 있음
3. **캐시문제**
Script는 캐시되긴 하지만, 동적 스크립트는 파라미터나 소스 코드가 조금만 달라도 다른 스크립트로 인식되기 때문에 캐시가 무효화 되고, 메모리 낭비가 발생함.


# 클러스터

---

클러스터는 **노드들을 하나로 묶어서**, **사용자는 내부 구조 몰라도 그냥 “하나의 시스템”처럼 쓸 수 있게 해주는 것.**

### 🔥 사실상 마스터 노드의 인터페이스?

**클러스터는 추상화된 개념(인터페이스)**이고,
**마스터 노드**는 그 클러스터의 동작을 구체적으로 실행하는 **구현체 역할**이다

즉, 클러스터가 실제로 수행하는 작업은 없다고 봐도 무방하다. 실제로 작업은 마스터 노드가 다 한다.

---

### 🔥 cluster State?

클러스터는 어떤 데이터가 어떤 노드에 저장되어 있는지 알 수 있는 cluster state를 가지고 있다. 그러나, 해당 정보는 마스터노드가 모든 결과를 생성하고 처리한 결과를 저장한 결과물일 뿐이다. 실제로 데이터를 몇개의 샤드로 나누고, 복제본은 몇개를 두고, 각 샤드를 어떤 노드에 넣을지 결정하는 것은 마스터 노드에서 작업이 이루어진다. 마스터 노드는 해당 작업이 완료되면 해당 정보를 클러스터에 전달하는 방식이다.

즉, **클러스터는 하나의 마스터 노드를 두고, 그 노드를 통해 전체 시스템의 상태를 결정하는 구조**를 가지게 된다.

---

# 노드

---

### 🔥 마스터 노드

요청을 받은 노드가 **coordinating node가 되고**, 데이터가 저장된 노드는 **data node가 되고**, 마스터 노드는 이 구조를 **유지·관리만**한다. 유지 관리는 cluster state로 한다. 즉, 마스터 노드는 데이터가 **저장된 구조 정보를 관리하는 역할**을 하기 때문에, **클러스터로 요청이 들어와도 마스터 노드가 직접적으로 하는 일은 없다고 봐도 무방**하다.

---

### 🔥 Coordinate Node가 필요한 이유

일반 노드가 존재하고 있다가.. 클러스터로 부터 쿼리를 받게 되는 그 순간! 해당 노드는 coordinate node가 된다.

메타 데이터는 Cluster state에 저장되어 있고, 모든 노드가 공유하고 있다. 그런데도 **coordinating node**가 필요한 이유는 단순히 "어디 있는지" 아는 것만으로는 부족하기 때문이다.

클러스터는 데이터를 **샤드 단위로 분산 저장**하고 있다. 예를 들어, 인덱스 `posts`가 있고. 5개의 샤드로 구성되어 있고, 각각 샤드는 여러 노드에 분산되어 있다.

사용자가 검색 요청을 보내면, 아래와 같은 프로세스가 진행된다.

1. **coordinating node**는 이 쿼리를 받아서
2. 관련된 모든 샤드(=노드)에 병렬로 전송하고
3. 각 노드에서 **partial result**(부분 결과)를 받아서
4. **정렬, 집계, 통합**한 다음 최종 결과로 만들어서 사용자에게 돌려준다.

**정렬, 집계, 통합**한 데이터는 **샤드에서 직접 처리 못 하고**, coordinating node에서 한 번에 처리한다.

---

### 🔥 전처리 노드 vs 변환 노드

**Ingest Node(전처리 노드)**와 **Transform Node(변환 노드)**는 둘 다 데이터를 가공/변환하는 역할을 하지만, 언제, 어디서, 무엇을 위해, 어떤 방식으로 작동하는지가 완전히 다르다.

- **Ingest Node**는 데이터가 **"ES에 들어오기 전에 세수하고 들어오게 만드는 애"**
- **Transform Node**는 이미 저장된 데이터들끼리 **"정리하고 통계내서 요약본 만들어주는 애"**

---

### 🔥 그럼 클러스터에 요청이 들어오면 어떤 유형의 노드가 처리해?

클러스터는 그런거 찾지 않는다. 그냥 아무 노드한테 요청을 전달한다. 그러면 그 노드는 자신이 가지고 있는 cluster state를 통해 어떤 노드가 데이터가 담긴 샤드를 가지고 있는지 파악해서 해당 샤드가 존재하는 data node에게 쿼리 전송한다.

마스터 노드는 cluster state를 정리해서 계속 노드들에게 공유한다.

---

# 인덱스

인덱스는 ElasticSearch에서 문서(Document)를 저장하고 관리하는 논리적 단위

인덱스는 단순히 "데이터 저장소"가 아니라, 색인과 검색 외에도 **스키마 정의, 설정 관리, 수명 제어, 접근 분리, 백업 단위** 등의 **ElasticSearch의 모든 데이터 운영의 기준 단위**

---

### 🔥 Inverted index란?

인덱스는 문서를 interved index 구조로 저장한다. 일반적인 index는 "문서 → 단어" 구조라면, **inverted index는 "단어 → 문서" 구조이다.**

| 일반적인 index (forward index) | inverted index |
| --- | --- |
| 문서 1: "고양이는 귀엽다" | "고양이" → 문서 1, 3, 9 |
| 문서 2: "강아지는 착하다" | "귀엽다" → 문서 1, 4 |
| 문서 3: "고양이 귀엽다 진짜" | "강아지" → 문서 2, 5 |

즉, 검색할 때마다 문서 전체를 쭉 훑는 게 아니라 **찾고자 하는** 단어가 등장한 문서만 바로 조회할 수 있는 구조이기 때문에 **검색 속도 폭발적으로 빠름.**

근데 여기서, 문장을 단어 단위로 쪼개는 것을 **토큰화**라고 하고, **ES에서는 analyzer를 통해 텍스트를 자동으로 쪼갠다.**

더불어 단어가 조금 달라도 일치하는 결과를 찾을 수 있도록 **정규화** 과정을 거친다. 소문자화, 어간추출, 특수문자 제거, 형태소 분석 등등…

---

# 샤드

---

샤드(Shard)는 ElasticSearch에서 **인덱스를 나눈 물리적/논리적 파티션 단위**이며, 실제 데이터를 저장하고 쿼리를 처리하는 **실질적인 데이터 처리 유닛이다.**

---

### 🔥 샤드의 위치!!!

Primary Shard든, replica shard든 모두 **DATA NODE에만 저장**된다. 다른 NODE에는 SHARD가 저장되지 않는다.

근데 샤드는 쿼리를 처리한다며? 그러면 전처리 노드, 변환 노드에도 샤드가 있어야 쿼리를 처리하는거 아냐?

→ 아니다. 전처리 노드, 변환 노드는 결국 쿼리를 생성해서 data node에 전송하거나, 파이프라인 처리만 진행하게 된다. 실제 작업은 data node에서만 실행하게 된다. 그리고 data node가 실행한 결과를 coordinate 노드가 결과를 집계하고 정렬하여 클러스터에 전달하는 것이다.

| 역할 | 하는 일 | 샤드 보유 여부 |
| --- | --- | --- |
| 🧠 **Coordinating Node** | 쿼리를 받아서 라우팅하고, 결과를 병합하고 정렬 | ❌ 없음 |
| 💾 **Data Node** | 샤드가 위치한 노드. 실제 쿼리 실행 수행 | ✅ 있음 |
| 🧪 **Ingest Node** | 색인 전에 파이프라인 처리만 함. 쿼리 실행 안 함 | ❌ 없음 |
| 🔁 **Transform Node** | 쿼리를 생성해서 Data Node에 날림. 직접 실행 안 함 | ❌ 없음 |

---

# 세그먼트

세그먼트(Segment)는 Lucene이 데이터를 저장할 때 사용하는 불변(immutable) 단위의 미니 인덱스다. 한 개의 샤드는 내부적으로 여러 개의 세그먼트를 가지며, 각 세그먼트는 자체적으로 독립된 색인(index), 문서 집합, 역색인 구조를 가지고 있음.

---

### 🔥 불변

세그먼트들은 모두 **불변(immutable)** 이기 때문에 수정이나 삭제 불가. 삭제는 "삭제 표시(tombstone)"만 남기고, **merge 시에 제거되는 구조.** 즉, 데이터를 merge를 해야만 오래된 버전의 세그먼트가 삭제되어 리소스 및 조회 성능이 향상되게 된다.

### 🔥 IMMUTABLE하게 데이터를 관리하는 것의 장점?

아무리 봐도 쓸데없는 리소스만 많이 잡아먹을 것 같은데, Immutable하게 데이터를 관리하는 이유는 뭘까?

RDB와 비교해보자. 일반적으로 RDB에서는 문서를 수정하거나 삭제할 때 동시성 제어를 위해 Lock을 건다. 트랜잭션이나 레코드 레벨 락이 걸리면 다른 쓰레드는 기다려야 하고 지연(latency)이 발생한다.

그러나, Elasticsearch는 문서를 수정하지 않고 "새로운 문서를 만들어서 인덱싱" 하기 때문에 기존 문서를 누가 참조하든 상관없이, Lock 없이 병렬로 처리가 가능하다.

Lock이 존재하지 않기 때문에 빠른 조회가 가능하고, 버전으로 Document를 관리하기 때문에 에러가 발생할 확률이 극히 낮아진다.

```
“When possible, prefer indexing new documents over updating existing ones — especially under high concurrency.”
```
-> 가능하다면 기존 문서를 업데이트하는 것보다 새 문서를 색인하는 것을 선호하세요. 특히 동시성이 높은 경우에는 더욱 그렇습니다.
